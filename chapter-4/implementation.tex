\section{Detale implementacji}\label{tesliper:implementation}
\subsection{Wybór języka programowania}\label{implementation:language}
\subsection{Ogólna architektura kodu}\label{implementation:architecture}
Program \tesliper{} ma strukturę obiektową\sidenote{%
    Dla ścisłości muszę tu zaznaczyć, że \tesliper{} nie jest w~pełni utrzymany w~stylu obiektowym.
    Python nie wymusza konkretnego paradygmatu programowania,
      pozwalając mieszać ze~sobą różne wzorce.
    Te jego części, które odpowiadają za~przeliczanie konkretnych danych w~inne \---
      bez uwzględniania kontekstu wcześniejszych działań \--- są napisane w~formie niezależnych
      funkcji, czerpiąc częściowo z~paradygmatu programowania funkcjonalnego.
    Takie podejście jest typowe dla~programów napisanych w~języku Python, i~można traktować
      je jako szczegół w~organizacji kodu.
    W~związku z~tym nie opisuję tej kwestii bardziej drobiazgowo.
  }, to znaczy wykorzystuje konstrukcje zwane obiektami,
  które zawierają zarówno dane, jak i~kod odpowiedzialny za~działania.
Ten styl programowania próbuje do~pewnego stopnia naśladować rzeczywisty świat \---
  obiekty mogą \enquote{posiadać} i~\enquote{robić}; reprezentują rzeczy lub idee.
Gdy obiekty \enquote{posiadają}, posiadane przez nich dane nazywa się atrybutami,
  natomiast możliwe działania obiektów są reprezentowane przez fragmenty kodu nazywane metodami.

Obiekty mogą posiadać inne obiekty \--- taka relacja nazywana jest kompozycją.
Innym rodzajem relacji między obiektami jest dziedziczenie.
Mówi się o~nim, gdy obiekt implementuje swoją funkcjonalność na~bazie innego obiektu.
Po~obiektach, będących w~relacji dziedziczenia względem tego samego \enquote{rodzica},
  można spodziewać się, że realizują podobne zadania i~\--- zależnie od~kontekstu \--- 
  można ich używać zamiennie.

Charakterystyczną cechą obiektów jest to, że mają pewien czas istnienia w~obrębie używającego ich
  programu komputerowego \--- są tworzone w~konkretnym celu i~przechowywane na~czas jego realizacji.
Programista, pisząc kod zorientowany obiektowo, przygotowuje szablony tworzenia obiektów,
  nazywane klasami.
Konkretny obiekt stworzony przez program na~podstawie takiego szablonu to egzemplarz klasy.

Ten skoncentrowany wstęp do~programowania obiektowego wystarczy, aby przybliżyć relacje między
  poszczególnymi konstruktami, z~których składa się kod \tesliper{}a oraz sposób jego działania.
\Cref{fig:class-diagram} przedstawia uogólniony diagram klas\sidenote{
    Nie w~scisłym znaczeniu diagramu \gls{uml}, jakie zwykle się za tym sformułowaniem kryje.
    Wspomniany \cref{fig:class-diagram} to raczej luźna graficzna reprezentacja.
  } wchodzących w~skład programu.
Ująłem na~nim również przepływ danych, aby unaocznić w~jaki sposób obiekty współpracują ze~sobą.

\begin{figure}
  \includesvg{class-diagram}
  \caption{
    Schematyczne przedstawienie architektury programu \tesliper{} oraz przepływu danych,
      począwszy od~plików wynikowych programu Gaussian do~zapisu przetworzonych danych
      na~dysk twardy.
    Legenda po~lewej stronie przybliża znaczenie poszczególnych elementów.
  }
  \label{fig:class-diagram}
\end{figure}

Obiekt \texttt{Tesliper} jest obiektem fasadowym, nazywanym tak przez nawiązanie do~architektury.
Tak jak fasada budynku, obiekt tego typu jest pierwszym, z~czym ma do~czynienia użytkownik.
Stanowi główny punkt dostępu do~funkcjonalności programu, ukrywając skomplikowane elementy
  systemu i~ułatwiając jego użycie.
\texttt{Tesliper} posiada obiekt \texttt{Conformers},
  który jest głównym magazynem danych \tesliper{}a.
W~jego obrębie wykonywana jest selekcja danych \--- posiada metody pozwalające
  na~zatrzymanie lub odrzucenie\sidenote{A~właściwie na~tymczasowe ignorowanie.}
  konformerów według zadanych parametrów.
Zapewnia również dostęp do~przechowywanych danych w~formie wyspecjalizowanych egzemplarzy
  klasy \texttt{DataArray}, a~dokładnie \--- klas po~niej dziedziczących.

Obiekty typu \texttt{DataArray} są centralnym elementem funkcjonalności \tesliper{}a.
Zapewniają dostęp do~metod odpowiedzialnych za~analizę danych dotyczących wybranych konformerów
  oraz przeliczanie tych danych na~finalne wartości.
Każdy rodzaj danych \--- wartości energii, geometria struktur, aktywności spektroskopowe, itd.
  \--- jest reprezentowany przez obiekt dedykowanej klasy, dziedziczącej po~\texttt{DataArray}.
Owa dedykowana klasa dostarcza adekwatnych metod transformacji danych, które do~niej należą.
Ponadto, podczas tworzenia tych obiektów, przeprowadzana jest dokładna walidacja danych \---
  sprawdzana jest ich spójność i~są one przekształcane w~formę tablic, na~których można
  wydajnie przeprowadzać operacje matematyczne.

\subsection{Odczyt i~zapis danych}\label{implementation:parsing}
Przetworzone dane na~dysk twardy \tesliper{} zapisuje za~pomocą wyspecjalizowanych na~format
  pliku docelowego obiektów typu \texttt{Writer}\sidenote{%
    Dziedziczących tak na~prawdę po~klasie \texttt{WriterBase},
      nieuwzględnionej na~\protect\cref{fig:class-diagram}.}.
Klasy te definiują metody zapisu i~sposób formatowania różnych rodzajów danych do~obsługiwanego
  przez siebie formatu plików.
Bardziej interesujący i~godny komentarza jest proces odczytu plików wynikowych programu Gaussian,
  zarządzany przez obiekt \texttt{Soxhlet}\sidenote{%
    Jest to, humorystyczne i~prawdopodobnie oczywiste, nawiązanie do~aparatu Soxhleta.
    Uznałem je za~adekwatne, bo w~końcu również służy do~ekstrakcji.
    Jeśli, czytelniku, uznasz, że jest ono nie na~miejscu, będę bronił się, cytując Phila Karltona,
      który twierdził, że \enquote{są tylko dwia trudne zagadnienia w~naukach komputerowych:
      unieważnienie pamięci podręcznej i~nazywanie rzeczy}.
  }.

\texttt{Soxhlet} posiada wyspecjalizowany obiekt typu \texttt{Parser}\sidenote{%
    Podobnie jak w~poprzednim przypadku, jest to obiekt dziedziczący tak na~prawdę po~klasie
      \texttt{ParserBase}, również nie uwzględnionej na~\protect\cref{fig:class-diagram}.
    W~przypadku opisywanych tutaj plików wynikowych programu Gaussian używany jest egzemplarz
      klasy \texttt{GaussianParser}.}
  który odpowiada za~odczyt danych tekstowych ze~wskazanego pliku i~przetworzenie ich
  na~dane liczbowe.
\texttt{Parser} odczytuje jeden plik na~raz.
Wyekstrahowane wartości przekazuje do~obiektu \texttt{Soxhlet}, który magazynuje je przed
  przekazaniem kompletu danych do~obiektu \texttt{Tesliper}.
\texttt{Soxhlet} jest też odpowiedzialny za~zawiadywanie pracą obiektu \texttt{Parser}.
Ustala, które pliki we~wskazanym folderze należy przetworzyć i~po~kolei przekazuje je
  obiektowi \texttt{Parser}.

Warto może w~tym miejscu powiedzieć czym w~ogóle jest parser.
W~ogólnym znaczeniu to program\sidenote{Lub jego część.} odpowiedzialny za~przetwarzanie tekstu
  \--- jego odczytywanie, wydobycie z~niego informacji i~przedstawienie ich w~języku i~formie,
  które zrozumie komputer\sidenote{%
    Takie wyjaśnienie jest, oczywiście, dalekie od~formalnej definicji parsera jako analizatora
      składniowego, ale myślę, że na~potrzeby niniejszej dysertacji jest wystarzcające.}.
W~przypadku danych zawartych w~plikach wynikowych programu Gaussian ważny jest również kontekst
  odczytywanych informacji.
Parser musi nie tylko rozpoznać, że dany ciąg znaków to liczba, ale również przypisać jej znaczenie
  \--- czy ta liczba to wartość energii czy ładunku cząsteczki; czy te koordynaty reprezentują
  geometrię zoptymalizowaną czy nie?

Aby umożliwić wydaje odczytywanie informacji z~takiej kontekstowej treści, zaimplementowałem
  obiekt \texttt{Parser} w~formie automatu skończonego.
Angielski odpowiednik tego terminu \--- \textit{finite state machine} \--- zdradza więcej
  informacji o~naturze tego modelu.
Jest to rodzaj \enquote{maszyny}, która może znajdować się w~pewnej skończonej liczbie stanów
  i~reagować na~bodźce w~sposób zależny od~tego, w~jakim stanie się akurat znajduje.
W~przypadku obiektu \texttt{Parser} bodźcami są informacje odczytywane z~przetwarzanego pliku,
  a~stany są tożsame z~kontekstem, w~jakim te informacje się znajdują.
Taki sposób przetwarzania danych pozwala nie tylko \enquote{zrozumieć} znaczenie odczytanych
  danych, ale również zminimalizować liczbę testów, które należy przeprowadzić w~danym momencie.

Przykładowo \--- jeśli \texttt{Parser} napotyka frazę \enquote{\texttt{Optimization completed}},
  to wejdzie w~stan \enquote{odczytywania zoptymalizowanej geometrii}.
Będzie wiedział, że ciągi liczb, które odczytuje, są reprezentacją atomów w~przestrzeni,
  i~że ma zapisać je w~pamięci jako geometrię optymalną właśnie.
Będzie wiedział też, że nie musi sprawdzać czy w~danym fragmencie znajduje się informacja
  o~wartości energii swobodnej Gibbsa, ani o~przejściach elektronowych w~stanie wzbudzonym.
Zacznie szukać tych innych treści dopiero gdy opuści obecny stan pod wpływem konkretnego bodźca
  \--- w~przykładowej sytuacji byłaby to pusta linia po~koordynatach ostatniego z~atomów.

\subsection{Analiza rozkładem Boltzmanna}\label{implementation:boltzmann}
\subsection{Metoda porównania geometrii}\label{implementation:rmsd}
\subsection{Obliczanie symulowanego widma}\label{implementation:spectra}
